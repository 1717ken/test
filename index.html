// hooks/use-canvas.ts
import { useState, useEffect, useRef } from "react";

interface Overlay {
  x: number;
  y: number;
  width: number;
  height: number;
}

export function useCanvas(
  productImage?: HTMLImageElement,
  logoImage?: HTMLImageElement,
  initialOverlay?: Overlay
) {
  const [overlay, setOverlay] = useState<Overlay>(
    initialOverlay || { x: 150, y: 150, width: 100, height: 100 }
  );
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const resizeHandleSize = 10;

  // キャンバスの描画関数
  const drawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    
    // キャンバスをクリア
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景を描画
    ctx.fillStyle = "#f8fafc";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 製品画像を描画
    if (productImage && productImage.complete) {
      const aspect = productImage.width / productImage.height;
      let w = canvas.width;
      let h = canvas.height;
      
      if (canvas.width / canvas.height > aspect) {
        w = canvas.height * aspect;
      } else {
        h = canvas.width / aspect;
      }
      
      const ox = (canvas.width - w) / 2;
      const oy = (canvas.height - h) / 2;
      
      ctx.drawImage(productImage, ox, oy, w, h);
    } else {
      ctx.fillStyle = "#94a3b8";
      ctx.font = "16px 'Noto Sans JP', sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("ここにグッズ画像が表示されます", canvas.width / 2, canvas.height / 2);
    }
    
    // ロゴ画像を描画
    if (logoImage && logoImage.complete) {
      ctx.drawImage(
        logoImage,
        overlay.x,
        overlay.y,
        overlay.width,
        overlay.height
      );
    } else if (!logoImage && productImage && productImage.complete) {
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.font = "12px 'Noto Sans JP', sans-serif";
      ctx.textAlign = "center";
      const centerX = overlay.x + overlay.width / 2;
      const centerY = overlay.y + overlay.height / 2;
      ctx.fillText("ロゴ未選択", centerX, centerY);
    }
    
    // オーバーレイガイドを描画
    if (productImage && productImage.complete) {
      ctx.save();
      ctx.strokeStyle = "rgba(239, 68, 68, 0.9)";
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(overlay.x, overlay.y, overlay.width, overlay.height);
      ctx.setLineDash([]);
      
      if (logoImage) {
        ctx.fillStyle = "rgba(59, 130, 246, 0.9)";
        ctx.fillRect(
          overlay.x + overlay.width - resizeHandleSize / 2,
          overlay.y + overlay.height - resizeHandleSize / 2,
          resizeHandleSize,
          resizeHandleSize
        );
      }
      
      ctx.restore();
    }
  };

  // マウスイベントハンドラ
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!productImage || !productImage.complete) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    const handleX = overlay.x + overlay.width - resizeHandleSize / 2;
    const handleY = overlay.y + overlay.height - resizeHandleSize / 2;
    
    if (logoImage && x >= handleX && x <= handleX + resizeHandleSize && 
        y >= handleY && y <= handleY + resizeHandleSize) {
      setIsResizing(true);
      setIsDragging(false);
    } else if (x >= overlay.x && x <= overlay.x + overlay.width && 
               y >= overlay.y && y <= overlay.y + overlay.height) {
      setIsDragging(true);
      setIsResizing(false);
      setDragOffset({
        x: x - overlay.x,
        y: y - overlay.y
      });
    }
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!productImage || !productImage.complete) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    if (isDragging) {
      const newX = x - dragOffset.x;
      const newY = y - dragOffset.y;
      
      setOverlay({
        ...overlay,
        x: Math.max(0, Math.min(canvas.width - overlay.width, newX)),
        y: Math.max(0, Math.min(canvas.height - overlay.height, newY))
      });
    } else if (isResizing && logoImage) {
      const newWidth = x - overlay.x;
      const newHeight = y - overlay.y;
      
      setOverlay({
        ...overlay,
        width: Math.max(resizeHandleSize * 2, Math.min(newWidth, canvas.width - overlay.x)),
        height: Math.max(resizeHandleSize * 2, Math.min(newHeight, canvas.height - overlay.y))
      });
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    setIsResizing(false);
  };

  // タッチイベントハンドラ
  const handleTouchStart = (e: React.TouchEvent<HTMLCanvasElement>) => {
    e.preventDefault();
    if (!productImage || !productImage.complete) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const touch = e.touches[0];
    const x = (touch.clientX - rect.left) * scaleX;
    const y = (touch.clientY - rect.top) * scaleY;
    
    const handleX = overlay.x + overlay.width - resizeHandleSize / 2;
    const handleY = overlay.y + overlay.height - resizeHandleSize / 2;
    
    if (logoImage && x >= handleX && x <= handleX + resizeHandleSize && 
        y >= handleY && y <= handleY + resizeHandleSize) {
      setIsResizing(true);
      setIsDragging(false);
    } else if (x >= overlay.x && x <= overlay.x + overlay.width && 
               y >= overlay.y && y <= overlay.y + overlay.height) {
      setIsDragging(true);
      setIsResizing(false);
      setDragOffset({
        x: x - overlay.x,
        y: y - overlay.y
      });
    }
  };

  const handleTouchMove = (e: React.TouchEvent<HTMLCanvasElement>) => {
    e.preventDefault();
    if (!productImage || !productImage.complete) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const touch = e.touches[0];
    const x = (touch.clientX - rect.left) * scaleX;
    const y = (touch.clientY - rect.top) * scaleY;
    
    if (isDragging) {
      const newX = x - dragOffset.x;
      const newY = y - dragOffset.y;
      
      setOverlay({
        ...overlay,
        x: Math.max(0, Math.min(canvas.width - overlay.width, newX)),
        y: Math.max(0, Math.min(canvas.height - overlay.height, newY))
      });
    } else if (isResizing && logoImage) {
      const newWidth = x - overlay.x;
      const newHeight = y - overlay.y;
      
      setOverlay({
        ...overlay,
        width: Math.max(resizeHandleSize * 2, Math.min(newWidth, canvas.width - overlay.x)),
        height: Math.max(resizeHandleSize * 2, Math.min(newHeight, canvas.height - overlay.y))
      });
    }
  };

  const handleTouchEnd = () => {
    setIsDragging(false);
    setIsResizing(false);
  };

  // キャンバスのサイズ調整
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const container = canvas.parentElement;
    if (!container) return;
    
    const containerWidth = container.clientWidth;
    
    if (containerWidth < 500) {
      const scale = containerWidth / 500;
      canvas.style.width = `${containerWidth}px`;
      canvas.style.height = `${500 * scale}px`;
    } else {
      canvas.style.width = "500px";
      canvas.style.height = "500px";
    }
    
    drawCanvas();
  }, [productImage, logoImage, overlay]);

  // 画像が変更されたときにキャンバスを再描画
  useEffect(() => {
    drawCanvas();
  }, [productImage, logoImage, overlay]);

  return {
    canvasRef,
    overlay,
    setOverlay,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd
  };
}
